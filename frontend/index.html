<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>R O L L E D</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://www.wuvt.vt.edu/static/css/wuvt.css?v=28">
  <script src="https://cdn.jsdelivr.net/npm/typesense@2/dist/typesense.min.js"></script>
  <script>
    // for some reason typesense treats pages 1 and 0 as the same thing, go figure.
    var page = 1;
    var search_flag = false;
    var typesense = new Typesense.Client({
      'nodes': [
        {
          'host': 'FE_TYPESENSE_HOST',
          'port': 'FE_TYPESENSE_PORT',
          'protocol': 'FE_TYPESENSE_PROTO'
        },
      ],
      'apiKey': 'FE_TYPESENSE_SEARCHKEY',
      'numRetries': 3,
      'connectionTimeoutSeconds': 2,
      'retryIntervalSeconds': 0.1,
      'healthcheckIntervalSeconds': 2,
      'logLevel': 'debug'
    })

    async function search(page)
    {
      var query = document.getElementById("search-input").value;

      let query_on = ""
      let toggles = [
        "album-title",
//        "tracklist", // it's wrong too frequently. unfuck later and restore.
        "artist-name",
        "label"
      ]
      for (let toggle of toggles)
      {
        let e = document.getElementById("toggle-"+toggle);
        if (e.checked)
        {
          query_on += toggle.replace("-", "_") + ","
        }
      }
      await typesense.collections("albums").documents().search({
        "q": query,
        "query_by": query_on,
        'page': page,
        'per_page': 10
      }).then(function (res) {
        if (res['hits'].length === 0) {
            search_flag = false;
            return;
        }
        let result_count = res["found"];
        let bucket = document.getElementById("search-results");
        bucket.innerHTML = result_count+" hits!";
        for (const hit of res["hits"])
        {
          let result = document.createElement("div");
          result.className = "search-result";

          let cover = document.createElement("img");
          cover.src = `https://coverartarchive.org/release/${hit.document["mbid"]}/front`;
          cover.className = "cover-art";
          cover.addEventListener("error", function() {
            if (this.src.includes("/release/") && hit.document["mbid"] != "") {
              this.src = `https://coverartarchive.org/release-group/${hit.document["release_group"]}/front`;
            }
            else if (this.src != "/assets/cover-404.png") {
              this.src = "/assets/cover-404.png";
            }
          });
          result.appendChild(cover);

          let info_wrapper = document.createElement("div");
          info_wrapper.className = "search-result-info";

          let used_info = [
            "album_title",
            "artist_name",
            "label",
            "release_year",
            "location",
            "mbid",
            "release_group"
          ];
          for (let v of used_info)
          {
            let info = document.createElement("div");
            info.className = "search-result-element "+v;
            info.innerHTML = hit.document[v];
            info_wrapper.appendChild(info);
          }
          
          let tracklist = document.createElement("details");
          let tracklist_title = document.createElement("summary");
          let tracklist_body = document.createElement("p");
          
          tracklist_title.innerHTML = "Songs";
          tracklist_body.innerHTML = hit.document["tracklist"];
          
          tracklist.className = "search-result-element tracklist";
          
          tracklist.appendChild(tracklist_title);
          tracklist.appendChild(tracklist_body);
          info_wrapper.appendChild(tracklist);
          
          result.appendChild(info_wrapper);

          bucket.appendChild(result);
        }
        search_flag = true;
      }).catch(function (error) {
        document.getElementById("search-results").innerHTML = error;
        search_flag = false;
      })
    }

    async function incrementSearch() {
        await search(page + 1);
        if (search_flag === true) {
            search_flag = false;
            page++;
        }
    }
    
    function decrementSearch() {
      if (page - 1 >= 1) {
        search(--page);
      }
    }
  </script>
</head>
<body>
  <div id="rolled-wrapper">
  <noscript>
    <h1>enable the js devilcode NOW!</h1>
  </noscript>
  <div id="rolled-header"></div>
  <div id="rolled-body">
  <div id="search-container">
      <input
        onchange   = "page = 1; search(page);"
        onkeypress = "this.onchange();"
        onpaste    = "this.onchange();"
        oninput    = "this.onchange();"
        id         = "search-input"
        type       = "text"
        placeholder= "search!"
      />
    <div id="search-undercarriage">
      <label>
        <input id="toggle-album-title" type="checkbox" onchange="page = 1; search(page);" checked>
        Album Titles
      </label>
      <!-- <label>
        <input id="toggle-tracklist" type="checkbox" onchange="search();" checked>
        Songs
      </label> -->
      <label>
        <input id="toggle-artist-name" type="checkbox" onchange="page = 1; search(page);" checked>
        Artist Names
      </label>
      <label>
        <input id="toggle-label" type="checkbox" onchange="page = 1; search(page);">
        Labels
      </label>
    </div>
  </div>
  <div id="search-results"></div>
  <div id="pagination-buttons">
    <button onclick="decrementSearch()">Previous page</button>
    <button onclick="incrementSearch()">Next page</button>
  </div>
  </div>
  <div id="rolled-footer">copyleft 2025 WUVT-FM division of e-teletype ops. (et al.)</div>
  <script>
    let header = document.getElementById("rolled-header");
    for (let char of "ROLLED")
    {
      let letter = document.createElement("h1");
      letter.innerHTML = char;
      header.appendChild(letter);
    }
  </script>
  </div>
  </body>
</html>
